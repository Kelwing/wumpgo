package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/dave/jennifer/jen"
)

var pascalRe = regexp.MustCompile(`[A-Z][a-z]+`)

func main() {
	if len(os.Args) != 2 {
		failErr(fmt.Errorf("expected at least one argument"))
	}

	structNames, err := getStructNamesFromFile(os.Args[1])
	if err != nil {
		panic(err)
	}

	if err := generate(structNames); err != nil {
		panic(err)
	}
}

func generate(sourceTypes []string) error {
	f := jen.NewFile(os.Getenv("GOPACKAGE"))
	f.PackageComment("Code generated by events generator, DO NOT EDIT.")
	f.Func().Id("eventHandlerToEvent").Params(jen.Id("h").Id("HandlerFunc")).
		Params(jen.Id("EventHandlerIface"), jen.String(), jen.Error()).
		Block(jen.Switch(jen.Id("v").Op(":=").Id("h").Assert(jen.Type())).BlockFunc(
			func(g *jen.Group) {
				for _, sourceType := range sourceTypes {
					g.Case(
						jen.Func().
							Params(
								jen.Qual("context", "Context"),
								jen.Qual("wumpgo.dev/wumpgo/rest", "RESTClient"),
								jen.Op("*").Qual("wumpgo.dev/wumpgo/objects", sourceType),
							),
					).Block(jen.Return(jen.Id("newHandler").Call(jen.Id("v")), jen.Lit(pascalToSnakeCase(sourceType)), jen.Nil()))
				}
				g.Default().Block(
					jen.Return(jen.Nil(), jen.Lit("invalid"), jen.Qual("fmt", "Errorf").Call(jen.Lit("invalid handler func"))),
				)
			},
		))

	filename := os.Getenv("GOFILE")
	ext := filepath.Ext(filename)
	baseName := filename[0 : len(filename)-len(ext)]
	newName := baseName + "_gen" + ext

	return f.Save(newName)
}

func getStructNamesFromFile(filePath string) ([]string, error) {
	structs := []string{}

	f, err := os.Open(filePath)
	if err != nil {
		return nil, err
	}

	data, err := io.ReadAll(f)
	if err != nil {
		return nil, err
	}

	fset := token.NewFileSet()
	pf, err := parser.ParseFile(fset, "", string(data), 0)
	if err != nil {
		return nil, err
	}

	for _, decl := range pf.Decls {
		gen, ok := decl.(*ast.GenDecl)
		if !ok || gen.Tok != token.TYPE {
			continue
		}

		for _, spec := range gen.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			if _, ok := ts.Type.(*ast.StructType); !ok {
				continue
			}

			structs = append(structs, ts.Name.Name)
		}
	}

	return structs, nil
}

func pascalToSnakeCase(in string) string {
	parts := pascalRe.FindAllString(in, -1)
	return strings.ToLower(strings.Join(parts, "_"))
}

func failErr(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}
