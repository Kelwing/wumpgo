// +build ignore

package main

import (
	"bytes"
	"io/ioutil"
	"strings"
	"text/template"
)

const start = `// Code generated by generate_command_builder.go; DO NOT EDIT.

package router

//go:generate go run generate_command_builder.go

import "github.com/Postcord/objects"

`

const choiceBuilder = `// {{ .TypeName }}AutoCompleteFunc is used to define the auto-complete function for {{ .ImportName }}.
// Note that the command context is a special case in that the response is not used.
type {{ .TypeName }}AutoCompleteFunc = func(*CommandRouterCtx) ([]{{ .ImportName }}, error)

// {{ .TypeName }}ChoiceBuilder is used to choose how this choice is handled.
// This can be nil, or it can pass to one of the functions. The first function adds static choices to the router. The second option adds an autocomplete function.
// Note that you cannot call both functions.
type {{ .TypeName }}ChoiceBuilder = func(addStaticOptions func([]{{ .ImportName }}), addAutocomplete func({{ .TypeName }}AutoCompleteFunc))

// {{ .TypeName }}StaticChoicesBuilder is used to create a shorthand for adding choices.
func {{ .TypeName }}StaticChoicesBuilder(choices []{{ .ImportName }}) {{ .TypeName }}ChoiceBuilder {
	return func(addStaticOptions func([]{{ .ImportName }}), _ func({{ .TypeName }}AutoCompleteFunc)) {
		addStaticOptions(choices)
	}
}

// {{ .TypeName }}AutoCompleteFuncBuilder is used to create a shorthand for adding a auto-complete function.
func {{ .TypeName }}AutoCompleteFuncBuilder(f {{ .TypeName }}AutoCompleteFunc) {{ .TypeName }}ChoiceBuilder {
	return func(_ func([]{{ .ImportName }}), addAutocomplete func({{ .TypeName }}AutoCompleteFunc)) {
		addAutocomplete(f)
	}
}

func (c *commandBuilder) {{ .TypeName }}Option(name, description string, required bool, choiceBuilder {{ .TypeName }}ChoiceBuilder) CommandBuilder {
	var discordifiedChoices []objects.ApplicationCommandOptionChoice
	var f {{ .TypeName }}AutoCompleteFunc
	if choiceBuilder != nil {
		choiceBuilder(func(choices []{{ .TypeName }}Choice) {
			if f != nil {
				panic("cannot set both function and choice slice")
			}
			discordifiedChoices = make([]objects.ApplicationCommandOptionChoice, len(choices))
			for i, v := range choices {
				discordifiedChoices[i] = objects.ApplicationCommandOptionChoice{Name: v.Name, Value: v.Value}
			}
		}, func(autoCompleteFunc {{ .TypeName }}AutoCompleteFunc) {
			if discordifiedChoices != nil {
				panic("cannot set both function and choice slice")
			}
			f = autoCompleteFunc
		})
	}

	c.cmd.Options = append(c.cmd.Options, &objects.ApplicationCommandOption{
		OptionType:   objects.Type{{ .TypeName }}{{ if eq .TypeName "Int" }}eger{{ end }},
		Name:         name,
		Description:  description,
		Required:     required,
		Choices:      discordifiedChoices,
		Autocomplete: f != nil,
	})
	if f != nil {
		if c.cmd.autocomplete == nil {
			c.cmd.autocomplete = map[string]interface{}{}
		}
		c.cmd.autocomplete[name] = f
	}
	return c
}`

const builderShared = `type {{ .Struct }} struct {
	*commandBuilder
}{{ if .AddOptions }}

func (c {{ .Struct }}) StringOption(name, description string, required bool, choiceBuilder StringChoiceBuilder) {{ .BuilderType }}Builder {
	c.commandBuilder.StringOption(name, description, required, choiceBuilder)
	return c
}

func (c {{ .Struct }}) IntOption(name, description string, required bool, choiceBuilder IntChoiceBuilder) {{ .BuilderType }}Builder {
	c.commandBuilder.IntOption(name, description, required, choiceBuilder)
	return c
}

func (c {{ .Struct }}) BoolOption(name, description string, required, default_ bool) {{ .BuilderType }}Builder {
	c.commandBuilder.BoolOption(name, description, required, default_)
	return c
}

func (c {{ .Struct }}) UserOption(name, description string, required bool) {{ .BuilderType }}Builder {
	c.commandBuilder.UserOption(name, description, required)
	return c
}

func (c {{ .Struct }}) ChannelOption(name, description string, required bool) {{ .BuilderType }}Builder {
	c.commandBuilder.ChannelOption(name, description, required)
	return c
}

func (c {{ .Struct }}) RoleOption(name, description string, required bool) {{ .BuilderType }}Builder {
	c.commandBuilder.RoleOption(name, description, required)
	return c
}

func (c {{ .Struct }}) MentionableOption(name, description string, required bool) {{ .BuilderType }}Builder {
	c.commandBuilder.MentionableOption(name, description, required)
	return c
}

func (c {{ .Struct }}) DoubleOption(name, description string, required bool, choiceBuilder DoubleChoiceBuilder) {{ .BuilderType }}Builder {
	c.commandBuilder.DoubleOption(name, description, required, choiceBuilder)
	return c
}{{ end }}

func (c {{ .Struct }}) DefaultPermission() {{ .BuilderType }}Builder {
	c.commandBuilder.DefaultPermission()
	return c
}

func (c {{ .Struct }}) AllowedMentions(config *objects.AllowedMentions) {{ .BuilderType }}Builder {
	c.commandBuilder.AllowedMentions(config)
	return c
}{{ if not .DoNotHook }}

func (c *commandBuilder) {{ .BuilderType }}() {{ .BuilderType }}Builder {
	c.cmd.commandType = int({{ .CommandType }})
	return {{ .Struct }}{c}
}{{ end }}`

const optionInterface = `type {{ .OutputInterface }} interface {
	// StringOption is used to define an option of the type string. Note that choices is ignored if it's nil or length 0.
	// Maps to option type 3 (STRING): https://discord.com/developers/docs/interactions/slash-commands#application-command-object-application-command-option-type
	StringOption(name, description string, required bool, choiceBuilder StringChoiceBuilder) {{ .InterfaceName }}

	// IntOption is used to define an option of the type int. Note that choices is ignored if it's nil or length 0.
	// Maps to option type 4 (INTEGER): https://discord.com/developers/docs/interactions/slash-commands#application-command-object-application-command-option-type
	IntOption(name, description string, required bool, choiceBuilder IntChoiceBuilder) {{ .InterfaceName }}

	// IntOption is used to define an option of the type bool.
	// Maps to option type 5 (BOOLEAN): https://discord.com/developers/docs/interactions/slash-commands#application-command-object-application-command-option-type
	BoolOption(name, description string, required, default_ bool) {{ .InterfaceName }}

	// IntOption is used to define an option of the type user.
	// Maps to option type 6 (USER): https://discord.com/developers/docs/interactions/slash-commands#application-command-object-application-command-option-type
	UserOption(name, description string, required bool) {{ .InterfaceName }}

	// ChannelOption is used to define an option of the type channel.
	// Maps to option type 7 (CHANNEL): https://discord.com/developers/docs/interactions/slash-commands#application-command-object-application-command-option-type
	ChannelOption(name, description string, required bool) {{ .InterfaceName }}

	// RoleOption is used to define an option of the type role.
	// Maps to option type 8 (ROLE): https://discord.com/developers/docs/interactions/slash-commands#application-command-object-application-command-option-type
	RoleOption(name, description string, required bool) {{ .InterfaceName }}

	// MentionableOption is used to define an option of the type mentionable.
	// Maps to option type 9 (MENTIONABLE): https://discord.com/developers/docs/interactions/slash-commands#application-command-object-application-command-option-type
	MentionableOption(name, description string, required bool) {{ .InterfaceName }}

	// DoubleOption is used to define an option of the type double. Note that choices is ignored if it's nil or length 0.
	// Maps to option type 10 (INTEGER): https://discord.com/developers/docs/interactions/slash-commands#application-command-object-application-command-option-type
	DoubleOption(name, description string, required bool, choiceBuilder DoubleChoiceBuilder) {{ .InterfaceName }}
}`

var choiceTypes = []struct {
	TypeName   string
	ImportName string
}{
	{
		TypeName:   "String",
		ImportName: "StringChoice",
	},
	{
		TypeName:   "Int",
		ImportName: "IntChoice",
	},
	{
		TypeName:   "Double",
		ImportName: "DoubleChoice",
	},
}

var builderTypes = []struct {
	Struct      string
	BuilderType string
	CommandType string
	DoNotHook   bool
	AddOptions  bool
}{
	{
		Struct:      "textCommandBuilder",
		BuilderType: "TextCommand",
		CommandType: "objects.CommandTypeChatInput",
		AddOptions:  true,
	},
	{
		Struct:      "subcommandBuilder",
		BuilderType: "SubCommand",
		CommandType: "objects.CommandTypeChatInput",
		DoNotHook:   true,
		AddOptions:  true,
	},
	{
		Struct:      "messageCommandBuilder",
		BuilderType: "MessageCommand",
		CommandType: "objects.CommandTypeMessage",
	},
	{
		Struct:      "userCommandBuilder",
		BuilderType: "UserCommand",
		CommandType: "objects.CommandTypeUser",
	},
}

var interfaceTypes = []struct {
	InterfaceName   string
	OutputInterface string
}{
	{InterfaceName: "CommandBuilder", OutputInterface: "commandOptions"},
	{InterfaceName: "SubCommandBuilder", OutputInterface: "subCommandOptions"},
	{InterfaceName: "TextCommandBuilder", OutputInterface: "textCommandOptions"},
}

func main() {
	file := start
	parts := make([]string, len(choiceTypes)+len(builderTypes)+len(interfaceTypes))
	t, err := template.New("_").Parse(choiceBuilder)
	if err != nil {
		panic(err)
	}
	for i, v := range choiceTypes {
		buf := &bytes.Buffer{}
		if err := t.Execute(buf, v); err != nil {
			panic(err)
		}
		parts[i] = buf.String()
	}
	t, err = template.New("_").Parse(builderShared)
	if err != nil {
		panic(err)
	}
	for i, v := range builderTypes {
		buf := &bytes.Buffer{}
		if err := t.Execute(buf, v); err != nil {
			panic(err)
		}
		parts[i+len(choiceTypes)] = buf.String()
	}
	t, err = template.New("_").Parse(optionInterface)
	if err != nil {
		panic(err)
	}
	for i, v := range interfaceTypes {
		buf := &bytes.Buffer{}
		if err := t.Execute(buf, v); err != nil {
			panic(err)
		}
		parts[i+len(choiceTypes)+len(builderTypes)] = buf.String()
	}
	file += strings.Join(parts, "\n\n") + "\n"
	if err := ioutil.WriteFile("command_builder_gen.go", []byte(file), 0666); err != nil {
		panic(err)
	}
}
