// Code generated by generate_response_builder.go; DO NOT EDIT.

package router

//go:generate go run generate_response_builder.go

import (
	"context"

	"github.com/Postcord/objects"
)

// UpdateLater is used to spawn the function specified in a goroutine. When the function is returned, the result is set as a message update.
func (c *ComponentRouterCtx) UpdateLater(f func(*ComponentRouterCtx) error) *ComponentRouterCtx {
	cpy := *c
	cpy.responseBuilder = responseBuilder{}
	go func() {
		defer func() {
			if errGeneric := recover(); errGeneric != nil {
				cpy.errorHandler(ungenericError(errGeneric))
			}
		}()
		var response *objects.InteractionResponse
		if err := f(&cpy); err == nil {
			response = cpy.buildResponse(false, cpy.errorHandler, cpy.globalAllowedMentions)
		} else {
			response = cpy.errorHandler(err)
		}
		// Need a better way to handle this context - the one on the RouterCtx will have been cancelled already
		// and can't be used
		processUpdateLaterResponse(context.Background(), cpy.RESTClient, cpy.ApplicationID, cpy.Token, response)
	}()
	return c
}

// DeferredChannelMessageWithSource is used to handle updating the response later. The user sees a loading state.
// Note that the chain does not continue after this since it is impossible to attach additional data.
func (c *ComponentRouterCtx) DeferredChannelMessageWithSource(f func(*ComponentRouterCtx) error) {
	c.respType = objects.ResponseDeferredChannelMessageWithSource
	c.UpdateLater(f)
}

// WithModalPath is used to set the response to the modal path specified.
func (c *ComponentRouterCtx) WithModalPath(path string) error {
	if c.modalRouter == nil {
		return UnsetModalRouter
	}
	return c.modalRouter.SendModalResponse(c, path)
}

// UpdateLater is used to spawn the function specified in a goroutine. When the function is returned, the result is set as a message update.
func (c *CommandRouterCtx) UpdateLater(f func(*CommandRouterCtx) error) *CommandRouterCtx {
	cpy := *c
	cpy.responseBuilder = responseBuilder{}
	go func() {
		defer func() {
			if errGeneric := recover(); errGeneric != nil {
				cpy.errorHandler(ungenericError(errGeneric))
			}
		}()
		var response *objects.InteractionResponse
		if err := f(&cpy); err == nil {
			response = cpy.buildResponse(false, cpy.errorHandler, cpy.globalAllowedMentions)
		} else {
			response = cpy.errorHandler(err)
		}
		// Need a better way to handle this context - the one on the RouterCtx will have been cancelled already
		// and can't be used
		processUpdateLaterResponse(context.Background(), cpy.RESTClient, cpy.ApplicationID, cpy.Token, response)
	}()
	return c
}

// DeferredChannelMessageWithSource is used to handle updating the response later. The user sees a loading state.
// Note that the chain does not continue after this since it is impossible to attach additional data.
func (c *CommandRouterCtx) DeferredChannelMessageWithSource(f func(*CommandRouterCtx) error) {
	c.respType = objects.ResponseDeferredChannelMessageWithSource
	c.UpdateLater(f)
}

// WithModalPath is used to set the response to the modal path specified.
func (c *CommandRouterCtx) WithModalPath(path string) error {
	if c.modalRouter == nil {
		return UnsetModalRouter
	}
	return c.modalRouter.SendModalResponse(c, path)
}

// UpdateLater is used to spawn the function specified in a goroutine. When the function is returned, the result is set as a message update.
func (c *ModalRouterCtx) UpdateLater(f func(*ModalRouterCtx) error) *ModalRouterCtx {
	cpy := *c
	cpy.responseBuilder = responseBuilder{}
	go func() {
		defer func() {
			if errGeneric := recover(); errGeneric != nil {
				cpy.errorHandler(ungenericError(errGeneric))
			}
		}()
		var response *objects.InteractionResponse
		if err := f(&cpy); err == nil {
			response = cpy.buildResponse(false, cpy.errorHandler, cpy.globalAllowedMentions)
		} else {
			response = cpy.errorHandler(err)
		}
		// Need a better way to handle this context - the one on the RouterCtx will have been cancelled already
		// and can't be used
		processUpdateLaterResponse(context.Background(), cpy.RESTClient, cpy.ApplicationID, cpy.Token, response)
	}()
	return c
}

// DeferredChannelMessageWithSource is used to handle updating the response later. The user sees a loading state.
// Note that the chain does not continue after this since it is impossible to attach additional data.
func (c *ModalRouterCtx) DeferredChannelMessageWithSource(f func(*ModalRouterCtx) error) {
	c.respType = objects.ResponseDeferredChannelMessageWithSource
	c.UpdateLater(f)
}
