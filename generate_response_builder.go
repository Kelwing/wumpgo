//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"io/ioutil"
	"strings"
	"text/template"
)

const start = `// Code generated by generate_response_builder.go; DO NOT EDIT.

package router

//go:generate go run generate_response_builder.go

import (
	"context"

	"github.com/Postcord/objects"
)

`

const singleStructureTemplate = `// UpdateLater is used to spawn the function specified in a goroutine. When the function is returned, the result is set as a message update.
func (c *{{ .Type }}) UpdateLater(f func(*{{ .Type }}) error) *{{ .Type }} {
	cpy := *c
	cpy.responseBuilder = responseBuilder{}
	go func() {
		defer func() {
			if errGeneric := recover(); errGeneric != nil {
				cpy.errorHandler(ungenericError(errGeneric))
			}
		}()
		var response *objects.InteractionResponse
		if err := f(&cpy); err == nil {
			response = cpy.buildResponse(false, cpy.errorHandler, cpy.globalAllowedMentions)
		} else {
			response = cpy.errorHandler(err)
		}
		// Need a better way to handle this context - the one on the RouterCtx will have been cancelled already
		// and can't be used
		processUpdateLaterResponse(context.Background(), cpy.RESTClient, cpy.ApplicationID, cpy.Token, response)
	}()
	return c
}

// DeferredChannelMessageWithSource is used to handle updating the response later. The user sees a loading state.
// Note that the chain does not continue after this since it is impossible to attach additional data.
func (c *{{ .Type }}) DeferredChannelMessageWithSource(f func(*{{ .Type }}) error) {
	c.respType = objects.ResponseDeferredChannelMessageWithSource
	c.UpdateLater(f)
}{{ if ne .Type "ModalRouterCtx" }}

// WithModalPath is used to set the response to the modal path specified.
func (c *{{ .Type }}) WithModalPath(path string) error {
	if c.modalRouter == nil {
		return UnsetModalRouter
	}
	return c.modalRouter.SendModalResponse(c, path)
}{{ end }}`

var types = []string{
	"ComponentRouterCtx", "CommandRouterCtx",
	"ModalRouterCtx",
}

func main() {
	file := start
	parts := make([]string, len(types))
	t, err := template.New("_").Parse(singleStructureTemplate)
	if err != nil {
		panic(err)
	}
	for i, v := range types {
		buf := &bytes.Buffer{}
		if err := t.Execute(buf, map[string]any{"Type": v}); err != nil {
			panic(err)
		}
		parts[i] = buf.String()
	}
	file += strings.Join(parts, "\n\n") + "\n"
	if err := ioutil.WriteFile("response_builder_gen.go", []byte(file), 0666); err != nil {
		panic(err)
	}
}
